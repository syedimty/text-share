{
  "name": "text-share",
  "version": "1.0.0",
  "description": "Application to share and collabrate in realtime",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/syedimty/text-share.git"
  },
  "keywords": [
    "text-share",
    "text",
    "collbaration"
  ],
  "author": "syed iMTY",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/syedimty/text-share/issues"
  },
  "homepage": "https://github.com/syedimty/text-share#readme",
  "dependencies": {
    "express": "^4.15.3"
  }
}
import com.sparkjava.spark.Spark;
import okhttp3.*;

import javax.net.ssl.*;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class ProxyApi {

    public static void main(String[] args) {
        Spark.port(8080);

        Spark.post("/api/proxy", (request, response) -> {
            try {
                // Extract request data
                String url = request.queryParams("url");
                String headers = request.queryParams("headers");
                String method = request.queryParams("method");
                String body = request.body();

                // Build the OkHttpClient with SSL support
                OkHttpClient client = getUnsafeOkHttpClient();

                // Build the request
                Request.Builder requestBuilder = new Request.Builder()
                        .url(url)
                        .method(method, RequestBody.create(MediaType.parse("application/json"), body));

                // Add headers to the request if available
                if (headers != null && !headers.isEmpty()) {
                    String[] headerArray = headers.split(",");
                    for (String header : headerArray) {
                        String[] headerParts = header.trim().split(":");
                        if (headerParts.length == 2) {
                            requestBuilder.addHeader(headerParts[0].trim(), headerParts[1].trim());
                        }
                    }
                }

                // Make the API call
                Response apiResponse = client.newCall(requestBuilder.build()).execute();

                // Return the response
                response.status(apiResponse.code());
                apiResponse.headers().toMultimap().forEach((key, values) -> values.forEach(value -> response.header(key, value)));
                return apiResponse.body().string();
            } catch (Exception e) {
                response.status(500);
                return "Error occurred: " + e.getMessage();
            }
        });
    }

    // Helper method to create an OkHttpClient that ignores SSL certificate validation
    private static OkHttpClient getUnsafeOkHttpClient() {
        try {
            // Create a trust manager that does not validate certificate chains
            final TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        public X509Certificate[] getAcceptedIssuers() {
                            return new X509Certificate[]{};
                        }
                    }
            };

            // Install the trust manager
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            // Configure OkHttpClient to ignore certificate errors
            OkHttpClient.Builder builder = new OkHttpClient.Builder();
            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);
            builder.hostnameVerifier((hostname, session) -> true);
            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

